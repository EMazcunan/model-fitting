[["index.html", "Ajuste de datos con R ", " Ajuste de datos con R Métodos Numéricos y Estadísticos Grado en Ingeniería Mecánica/Informática Curso 2021-2022 Universidad de León Eva María Mazcuñán Navarro "],["intro.html", "Introducción", " Introducción En esta práctica estudiaremos cómo ajustar un modelo a un conjunto de datos experimentales, mediante la técnica de mínimos cuadrados, usando R. Mientras que en los problemas que hemos a mano hasta ahora hemos considerado únicamente modelos lineales de uno o dos parámetros, en esta práctica consideraremos modelos tanto lineales como no lineales, y con un número arbitrario de parámetros. También podremos trabajar con un número de datos mucho más elevado que en los problemas resueltos a mano. Seguiremos trabajando con una variable dependiente \\(y\\) y una única variable dependiente \\(x\\), aunque las técnicas que presentaremos se generalizan sin dificultad al caso de varias variables independientes. "],["prerequisites.html", "Requisitos previos", " Requisitos previos Antes de comenzar esta práctica, necesitas: Tener R y RStudio instalados en tu equipo (ver Instalación de R y RStudio). Haber estudiado la práctica Primeros pasos con R y RStudio. "],["workflow.html", "Flujo de trabajo", " Flujo de trabajo Documenta lo que vayas aprendiendo conforme leas la práctica usando un documento R Markdown. Puedes utilizar esta plantilla. Se recomienda guardar el archivo R Markdown en una carpeta propia. En dicha carpeta se creará el archivo HTML resultante de la compilación y después añadiremos los archivos con los datos que usaremos a lo largo de la práctica. Recuerda que para crear encabezados se utiliza la sintaxis # (nivel 1), ## (nivel 2), …; y que los bloques de código se crean con el atajo Ctrl + Alt + I. Respecto al seccionado del documento, lo más práctico es que imites la estructura de este guión de prácticas. "],["packages.html", "1 Paquetes", " 1 Paquetes Para utilizar las funciones que aparecerán a lo largo de la práctica empezamos cargando el paquete tidyverse: library(&quot;tidyverse&quot;) Aunque se puede cargar un paquete en cualquier punto de un documento R Markdown, se considera una buena práctica cargar todos los paquetes al inicio. Así que, si a lo largo de la práctica fuera necesario cargar más paquetes, escribe la correspondiente instrucción para cargarlos con la función library() al comienzo de tu documento, junto con esta primera instrucción. "],["lm.html", "2 Modelos lineales", " 2 Modelos lineales Como hemos visto en teoría, dada una variable dependiente \\(y\\) y una variable independiente \\(x\\), un modelo lineal de parámetros \\(\\beta_1\\), \\(\\beta_2\\), … \\(\\beta_p\\) tiene la forma \\[ y = \\beta_1 f_1(x) + \\beta_2 f_2(x) + \\dots +\\beta_p f_p(x), \\] siendo \\(f_1\\), \\(f_2\\), \\(\\dots\\), \\(f_p\\) funciones conocidas. En este capítulo veremos cómo ajustar este tipo de modelos para un conjunto observaciones usando la función lm() (linear model) de R. Veremos también cómo representar gráficamente un ajuste usando la función geom_smooth() del paquete ggplot2. "],["planteamiento-del-problema-el-prisma-de-vidrio.html", "2.1 Planteamiento del problema: El prisma de vidrio", " 2.1 Planteamiento del problema: El prisma de vidrio Newton demostró con el prisma que la luz blanca es una mezcla de varios colores y que la refracción depende del color (longitud de onda). En un experimento, se eligieron diferentes longitudes de onda \\(\\lambda\\) y se trazó el camino seguido por el rayo de luz que atraviesa el prisma, midiendo el ángulo de desviación para, a partir del mismo, calcular el índice de refracción \\(n\\) del vidrio para el color seleccionado. Los datos obtenidos se recogen en el archivo refraction.csv(click para descargar), que contiene las variables: lambda: longitud de onda \\(\\lambda\\), medida en \\(nm\\). n: índice de refracción. Descarga el fichero refraction.csv y guárdalo en una carpeta de nombre data dentro de tu directorio de trabajo. Importamos los datos con read_csv() y los guardamos en un objeto de nombre refraction: refraction &lt;- read_csv(&quot;data/refraction.csv&quot;) Visualizamos los datos dibujando la nube de puntos \\((\\lambda, n)\\) con geom_point(): ggplot( data = refraction, mapping = aes(x = lambda, y = n) ) + geom_point() "],["ajuste-con-lm.html", "2.2 Ajuste con lm()", " 2.2 Ajuste con lm() Tomaremos como modelo la fórmula de Cauchy para los índices de refracción \\(n\\) en la región visible del espectro de longitud de onda \\(\\lambda\\): \\[n(\\lambda) = \\beta_1 + \\frac{\\beta_2}{\\lambda^2} + \\frac{\\beta_3}{\\lambda^4}\\] donde \\(\\beta_1\\), \\(\\beta_2\\) y \\(\\beta_3\\) son los parámetros a ajustar. Como se indicó antes, la función de R para ajustar modelos lineales es lm(). En la siguiente instrucción se utiliza la función lm() para ajustar el modelo propuesto a las observaciones de nuestra hoja de datos, y se guarda el resultado en un objeto de nombre fit_cauchy: fit_cauchy &lt;- lm( data = refraction, formula = n ~ I(1 / lambda^2) + I(1 / lambda^4) ) En el código anterior, hemos usado los argumentos data, para especificar la hoja de datos con las observaciones, y formula, para indicar la fórmula del modelo (enseguida explicaremos cómo construir esta fórmula). El resultado se almacena en un objeto de nombre fit_cauchy. Si imprimimos el objeto fit_cauchy veremos los coeficientes del ajuste: fit_cauchy Call: lm(formula = n ~ I(1/lambda^2) + I(1/lambda^4), data = refraction) Coefficients: (Intercept) I(1/lambda^2) I(1/lambda^4) 1.5 4908.3 7078041.7 La instrucción summary(fit_cauchy) revela que el objeto fit_cauchy contiene mucha más información de la que muestra su simple impresión: summary(fit_cauchy) Call: lm(formula = n ~ I(1/lambda^2) + I(1/lambda^4), data = refraction) Residuals: Min 1Q Median 3Q Max -1.294e-03 -4.672e-04 1.711e-05 2.982e-04 2.216e-03 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 1.500e+00 7.676e-04 1954.496 &lt; 2e-16 *** I(1/lambda^2) 4.908e+03 4.342e+02 11.303 1.02e-13 *** I(1/lambda^4) 7.078e+06 5.376e+07 0.132 0.896 --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 0.0007213 on 38 degrees of freedom Multiple R-squared: 0.9912, Adjusted R-squared: 0.9907 F-statistic: 2131 on 2 and 38 DF, p-value: &lt; 2.2e-16 Ésta es la razón por la que hemos creado el objeto fit_cauchy para almacenar la salida de la función lm(): lo usaremos en los siguientes apartados para extraer información del ajuste realizado. "],["fórmulas-en-r.html", "2.3 Fórmulas en R", " 2.3 Fórmulas en R Al usar la función lm(), hemos indicado el siguiente valor para el argumento formula : n ~ I(1/lambda^2) + I(1/lambda^4) La expresión anterior es un objeto de R de tipo formula, que se corresponde con la fórmula de Cauchy que estamos usando como módelo \\[n(\\lambda) = \\beta_1 + \\frac{\\beta_2}{\\lambda^2} + \\frac{\\beta_3}{\\lambda^4}.\\] En la siguiente tabla se muestran algunos ejemplos más de fórmulas en R correspondientes a diferentes modelos: Modelo formula \\(y=\\beta_1+\\beta_2x\\) y ~ x \\(y=\\beta_1 x\\) y ~ 0 + x \\(y=\\beta_1 + \\beta_2 x + \\beta_3 x^2\\) y ~ x + I(x^2) \\(y=\\beta_1 \\cos(x)+ \\beta_2\\sin(x)\\) y ~ 0 + I(cos(x)) + I(sin(x)) Para especificar la fórmula de un modelo en R hay que tener en cuenta las siguientes reglas: Cada sumando en una fórmula de R, indica la función que multiplica a un parámetro em la fórmula del modelo. Así, el sumando x en una fórmula de R será un sumando de la forma \\(\\beta_ix\\) en la fórmula matemática del modelo. R añade siempre una constante como primer sumando de la fórmula del modelo (\\(\\beta_1\\) en los ejemplos anteriores). Para evitar la inclusión automática de esa constante hay que escribir el sumando 0. Así, la fórmula y ~ x se corresponde con \\(y = \\beta_1 + \\beta_2x\\); y si se quiere omitir la constante \\(\\beta_1\\), se ha de escribir y ~ 0 + x. Las funciones que son una transformación de la variable independiente se han de escribir incluidas en la función identidad I(). Por ejemplo, un término de la forma \\(\\beta_i x^2\\) en la fórmula de un modelo se escribe en R como I(x^2). "],["coeficientes.html", "2.4 Coeficientes", " 2.4 Coeficientes Para obtener los coeficientes del ajuste usamos la función coefficients(): coefficients(fit_cauchy) (Intercept) I(1/lambda^2) I(1/lambda^4) 1.500310e+00 4.908268e+03 7.078042e+06 La salida nos informa de que los coeficientes que solucionan el problema de mínimos cuadrados (ecuaciones normales de Gauss) son: \\[\\hat{\\beta_1} = 1.50031,\\] \\[\\hat{\\beta_2} = 4908.268,\\] y \\[\\hat{\\beta_3} = 7078042.\\] Nota: Dependiendo de la configuración, los valores de la salida pueden aparecer en notación científica, simbolizando e+00, e+03 y e+06 que hay que multiplicar por \\(10^0=1\\), \\(10^3=1000\\) y \\(10^6=1000000\\) respectivamente. Por tanto el ajuste buscado es \\[n(\\lambda) = 1.50031 + \\frac{4908.268}{\\lambda^2} + \\frac{7078042}{\\lambda^4}.\\] "],["valores-ajustados.html", "2.5 Valores ajustados", " 2.5 Valores ajustados Los valores ajustados (o esperados) para la variable dependiente se obtienen con la función fitted(): fitted(fit_cauchy) 1 2 3 4 5 6 7 8 1.534640 1.532886 1.531263 1.529759 1.528362 1.527062 1.525851 1.524721 9 10 11 12 13 14 15 16 1.523664 1.522674 1.521746 1.520875 1.520056 1.519285 1.518558 1.517873 17 18 19 20 21 22 23 24 1.517225 1.516613 1.516033 1.515484 1.514963 1.514468 1.513998 1.513552 25 26 27 28 29 30 31 32 1.513126 1.512721 1.512335 1.511967 1.511615 1.511279 1.510958 1.510650 33 34 35 36 37 38 39 40 1.510356 1.510074 1.509804 1.509545 1.509297 1.509058 1.508829 1.508608 41 1.508396 "],["residuos.html", "2.6 Residuos", " 2.6 Residuos Para obtener los residuos del ajuste (\\(\\varepsilon_i\\)) usamos la función residuals(): residuals(fit_cauchy) 1 2 3 4 5 -5.158258e-04 1.192086e-04 -9.157603e-05 8.724810e-04 9.998852e-05 6 7 8 9 10 2.981569e-04 -6.063847e-04 6.853349e-04 -8.594240e-04 -3.992586e-04 11 12 13 14 15 4.507231e-05 4.592263e-05 -2.575917e-04 6.782515e-04 5.616847e-05 16 17 18 19 20 -1.021129e-04 -4.671765e-04 4.270844e-04 -1.002945e-03 2.215907e-03 21 22 23 24 25 -5.376294e-04 6.594862e-04 1.524706e-04 6.591191e-04 -9.333365e-04 26 27 28 29 30 -5.619564e-04 -8.481528e-04 9.871010e-05 -1.294146e-03 1.065956e-04 31 32 33 34 35 -2.355407e-04 1.609116e-03 -2.899098e-04 -2.667854e-04 -8.491117e-04 36 37 38 39 40 -3.842938e-04 1.710620e-05 2.483173e-04 8.932864e-04 7.950677e-04 41 -2.796932e-04 Para calcular el error cuadrático del ajuste (\\(RSS\\)) usamos sum(residuals(fit_cauchy)^2) [1] 1.976785e-05 En el resumen del ajuste podemos leer Residual standard error: 0.0007213 on 38 degrees of freedom El error estandard residual, que suele denotarse \\(\\sigma\\), se obtiene con la función sigma(). sigma(fit_cauchy) [1] 0.0007212534 La relación entre esta cantidad \\(\\sigma\\) y el error cuadrático \\(RSS\\) es: \\[\\sigma = \\sqrt{RSS/38}\\] o equivalentemente \\[RSS=38\\sigma^2.\\] El valor \\(38\\), se llama grados de libertad de los residuos y se obtiene de restar, a las \\(n=41\\) observaciones, los \\(p=3\\) parámetros del modelo. Se obtiene con la función df.residual(). Comprobamos la relación entre el error residual estandar y \\(RSS\\): df.residual(fit_cauchy) * sigma(fit_cauchy)^2 # RSS [1] 1.976785e-05 "],["predicciones.html", "2.7 Predicciones", " 2.7 Predicciones La siguiente tabla recoge las longitudes de onda correspondientes a algunos colores del arcoiris: Color \\(\\lambda\\) Rojo 640 Amarillo 589 Verde 509 Azul 486 Violeta 434 Queremos calcular los índices de refracción que predice nuestro ajuste para los colores anteriores. Para hacerlo usamos la función predict(): # hoja de datos con los nuevos valores de lambda new_lambda &lt;- tibble( lambda = c(640, 589, 509, 486, 434) ) # predicciones predict( fit_cauchy, new_lambda ) 1 2 3 4 5 1.512335 1.514517 1.519360 1.521217 1.526568 En la función predict() indicamos como primer argumento nuestro ajuste fit_cauchy y como segundo argumento una hoja de datos, que hemos llamado new_lambda, con los nuevos valores para la variable independiente lambda. Hemos construido dicha hoja de datos con la función tibble() (tidy table). "],["gráfico-del-ajuste.html", "2.8 Gráfico del ajuste", " 2.8 Gráfico del ajuste Al comienzo del problema representamos la nube de puntos de nuestras observaciones con la función geom_point(). Añadimos ahora el gráfico del ajuste con la función geom_smooth(): ggplot( data = refraction, mapping = aes(x = lambda, y = n) ) + geom_point() + geom_smooth( method = &quot;lm&quot;, formula = y ~ I(1 / x^2) + I(1 / x^4), se = FALSE ) En los argumentos de geom_smooth() hemos escrito method = &quot;lm&quot; para indicar que el ajuste se realiza con la función lm(). Notar que al especificar la fórmula del modelo en el argumento formula no se utilizan los nombres lambda y n de las variables –como se hizo en la función lm()– sino los nombres x e y de las estéticas asociadas. El argumento se = FALSE inhibe representar los intervalos de confianza (que estudiaremos en el último tema del curso). "],["nls-tbc.html", "3 Modelos no lineales", " 3 Modelos no lineales Modelos como \\[y = \\beta_1 \\beta_2^{x}\\] (modelo exponencial) o como \\[y = \\beta_1x^{\\beta_2}\\] (modelo potencial) no tienen una estructura lineal. Para modelos lineales, el problema de encontrar los valores de los parámetros que minimizan el error cuadrático del ajuste se traduce en resolver el sistema de ecuaciones normales de Gauss, que es un sistema lineal. Pero en el caso de modelos no lineales como los anteriores, la situación se complica porque ahora la solución viene dada por un sistema de ecuaciones no lineales. En este capítulo veremos cómo ajustar este tipo de modelos a una colección de observaciones, usando la función nls() (nonlinear least squares) de R. "],["tbc.html", "3.1 Continuará …", " 3.1 Continuará … "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
